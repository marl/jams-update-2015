% -----------------------------------------------
% Template for ISMIR Papers
% 2015 version, based on previous ISMIR templates
% -----------------------------------------------

\documentclass{article}
\usepackage{ismir,amsmath,cite}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage{listings}
\usepackage{url}
\usepackage{cleveref}
\usepackage{authblk}
\usepackage{booktabs}
\usepackage{bera}
\usepackage{multirow}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=none,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\lstset{language=python,frame=none,numbers=none}
\lstset{language=json,frame=lines,numbers=none}

\renewcommand\Authfont{\bfseries}

% Title.
% ------
\title{Pump up the JAMS: v0.2 and beyond}

% Multiple authors
% To use with multiple author with possibly different addresses
% ---------------
%\multauthor
%{First author$^1$ \hspace{1cm} Second author$^1$ \hspace{1cm} Third author$^2$} { \bfseries{Fourth author$^3$ \hspace{1cm} Fifth author$^2$ \hspace{1cm} Sixth author$^1$}\\
  %$^1$ Department of Computer Science, University , Country\\
%$^2$ International Laboratories, City, Country\\
%$^3$  Company, Address\\
%{\tt\small CorrespondenceAuthor@ismir.edu, PossibleOtherAuthor@ismir.edu}
%}
%\def\authorname{First author, Second author, Third author, Fourth author, Fifth author, Sixth author}

% Single address
% To use with only one author or several with the same address
% ---------------
%\oneauthor
% {Names should be omitted for double-blind reviewing}
% {Affiliations should be omitted for double-blind reviewing}

% Two addresses
% --------------
%\twoauthors
%  {First author} {School \\ Department}
%  {Second author} {Company \\ Address}

% Three addresses
% --------------
%\threeauthors
%  {First author} {Affiliation1 \\ {\tt author1@ismir.edu}}
%  {Second author} {Affiliation2 \\ {\tt author2@ismir.edu}}
%  {Third author} {Affiliation3 \\ {\tt author3@ismir.edu}}

% Four addresses
% --------------
%\fourauthors
%  {First author} {Affiliation1 \\ {\tt author1@ismir.edu}}
%  {Second author}{Affiliation2 \\ {\tt author2@ismir.edu}}
%  {Third author} {Affiliation3 \\ {\tt author3@ismir.edu}}
%  {Fourth author} {Affiliation4 \\ {\tt author4@ismir.edu}}

\author[1,2,*]{Brian~McFee}
\author[4]{Eric~J. Humphrey}
\author[5]{Oriol~Nieto}
\author[1,3]{Justin~Salamon}
\author[1]{Rachel~Bittner}
\author[1]{Jon~Forsyth}
\author[1]{Juan~P. Bello}
\affil[1]{Music and Audio Research Laboratory, New York University}
\affil[2]{Center for Data Science, New York University}
\affil[3]{Center for Urban Science and Progress, New York University}
\affil[4]{MuseAmi, Inc.}
\affil[5]{Pandora, Inc.}

\def\authorname{Brian~McFee, Eric~J. Humphrey, Oriol~Nieto, Justin~Salamon,
    Rachel~M. Bittner, Jon~Forsyth, Juan~P. Bello}

\begin{document}
%
\maketitle
%
\let\oldthefootnote\thefootnote%
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\footnotetext[1]{Please direct correspondence to \url{brian.mcfee@nyu.edu}}
\let\thefootnote\oldthefootnote%
%
\begin{abstract}
This document describes the changes to the JSON Annotated Music Specification (JAMS)
format and implementation between v0.1 and v0.2.
\end{abstract}
%
\section{Introduction}\label{sec:introduction}

The JSON Annotated Music Specification (JAMS) format was proposed by Humphrey \emph{et al.}~\cite{jams2014}
as a mechanism to serialize structured annotations for musical content.
Since the initial publication of the JAMS specification, we (the developers) have learned several lessons in building music information retrieval infrastructure on top of the existing
framework.
Consequently, we have revised the specification and implementation in various ways to better support a modern and extensible workflow.
The purpose of this document is to explain the changes in JAMS following the first publication, describe their underlying motivation, and demonstrate how to effectively apply the current
(v0.2.0) implementation.

Throughout this document, the previous specification of JAMS as described by Humphrey
\emph{et al.}~\cite{jams2014} will be referred to as \emph{JAMS-0.1}, while the current
specification will be referred to as \emph{JAMS-0.2}.

\section{JAMS specification}\label{sec:schema}
In this section, we highlight the changes to the JAMS schema definition(s).
Since these changes apply to the file structure definition itself, they are independent of the software implementation used to parse or generate JAMS files.


\subsection{Unified observation types}\label{sec:schema:annotations}

In JAMS-0.1, there are four basic data types:
\begin{itemize}
    \item \emph{observation},
    \item \emph{event},
    \item \emph{range}, and
    \item \emph{time series}.
\end{itemize}
The \emph{observation} type is used to encode a fixed observed quantity, such as as chord label or semantic tag, as well as a quantitative
measure of confidence in the value.\footnote{A secondary value field is also provided, but we ignore it here for expository purposes.}
The latter three types define different ways of encoding the time index of an observation.
\emph{Event} is used for observations with no temporal duration (such as beats or onsets);
\emph{range} is used for observations that span a fixed portion of time (such as chords or segments); 
and \emph{time series} is used to encode temporally continuous observations, such as melodic contours.

These three distinct views lead to efficient, compact representations, but can be difficult to work with in practice.  Different
tasks generally use different time index types, so the practitioner must both be aware of which index is 
used for any given task, and write code to handle it accordingly.
Moreover, it becomes non-trivial to temporally align annotations across different tasks, since they must first be mapped into a common representation.

JAMS-0.2 simplifies this by reducing all observation types to a single format: regardless of task, each \emph{observation} consists of a 
4-tuple \emph{(time, duration, value, confidence)}.
The \emph{time} and \emph{duration} fields are constrained by the schema to be non-negative numbers.\footnote{The \emph{value} and
\emph{confidence} fields are left unconstrained at this point, but are defined subsequently depending on the \emph{namespace} as defined
in \cref{sec:schema:task}.}
By default, this simulates the \emph{range} type of JAMS-0.1, but taking \emph{duration}$=0$ recovers the \emph{event}
type as well, with a small amount of redundancy.

The \emph{time series} type of JAMS-0.1 can be viewed as an efficiently coded, dense sequence of \emph{range} observations with implicit
durations.
Recall that in JAMS-0.1, each \emph{Annotation} object contains a list of observations in its \emph{data} field.
For high-frequency observations --- such as melodic contours, sampled at 10Hz or greater --- encoding a 4-tuple for each
sample would be inefficient, due to redundantly listing the keys \emph{time, value, duration, confidence}.
JAMS-0.2 circumvents this by allowing a distinction between \emph{sparse} and \emph{dense} observation lists.
Note that having standardized the observation format, the \emph{Annotation}'s data field can be interpreted as an $n\times 4$ table, which
may be encoded in either a row-major (\emph{sparse}) or column-major (\emph{dense}) format.
While the column-major format is generally more spatially efficient, the row-major format is more human-legible, 
and for most tasks, the difference in efficiency is negligible.

Standardizing the observation format both simplifies upstream code to interact with JAMS objects, and generalizes the previous
definitions. (For instance, time series now have explicit durations/sampling rates, and gaps in observations are now permitted.)
The one thing that we lose in this process is the notion of time-independent annotations, such as \emph{tag}, \emph{genre}, and \emph{mood} 
in JAMS-0.1.
This is because all observations in JAMS-0.2 are required to have a time and (potentially 0) duration.
However, we argue that this is an advantage for three reasons.
First, it is possible to have full-track observations by setting \emph{time}$=0$ and $\emph{duration}$ to the full track duration, so no functionality is lost.
Second, in reality, every observation type may vary over time, so the schema should support this explicitly.
Finally, it forces the annotator to be explicit about the valid timing of an observation, and facilitates partial annotation (see \cref{sec:future}).

\subsection{Task- vs. Annotation-major layout}\label{sec:schema:task}

As illustrated in Figure~\cref{jams1}, JAMS-0.1 took a \emph{task-major} approach to structuring annotations.  A collection of supported tasks was
defined within the JAMS-0.1 schema, such as \emph{tag}, \emph{genre}, \emph{chord}, \emph{key}, \emph{melody}, \emph{etc}.  Annotations of a
particular task would then be accessed by indexing the array of annotations corresponding to that task, \emph{e.g.}:
\begin{lstlisting}[language=json]
  jams_object.beat[0]
\end{lstlisting}

This structure is conceptually simple and easy to work with, but it poses several practical limitations.
First, it requires that all tasks be specified \emph{a priori} within the JAMS schema.
Consequently, each time a new task is introduced in the future, the core JAMS schema must be modified to accommodate it.
This is clearly undesirable, as it could lead to fragmentation of the JAMS specification if (when) different groups decide to extend the task definitions in one direction or another.

Second, it provides no means of distinguishing between different variations of a task.
As a simple example, take the case of \emph{tags}.
Different data sets are annotated using different vocabularies, which may be closed
(\emph{e.g.}, GTZAN or CAL500) or open (\emph{e.g.}, last.fm).
This implies that the validity of a tag annotation depends upon the target vocabulary, which is not explicitly coded within the schema.
(Indeed, an exhaustive coding of \emph{all} tag vocabularies within a fixed schema is impossible.) 
As a more nuanced example, \emph{chord} annotations can be drawn from different vocabularies (\emph{e.g.}, including or suppressing extensions),
or even radically different annotation styles, such as the pop-style annotations of Isophonics compared to the roman numeral annotations of the
Rock corpus.
In these cases, it is hardly sensible to group these variations together under a single task, since their annotations are not directly
comparable.

To resolve these issues, JAMS-0.2 adopts an an\-notation-major (rather than task-major) structure.
Instead of grouping annotations by task at the top-level, a JAMS-0.2 object contains a single list of \emph{Annotations}.
This allows for the same core schema to be retained as new tasks are introduced, since there is no explicit dependence on the task
definitions.
However, since all annotations are collected in a single, anonymous data structure, we will need a new way to distinguish between annotations for different tasks.
This leads us to the task \emph{namespace} abstraction.

\subsection{Task namespaces}\label{sec:schema:namespace}
Each annotation object declares its task through a string-valued field called \emph{namespace}.
A \emph{namespace} in JAMS-0.2 is simply a partial schema declaration which defines the following properties:
\begin{itemize}
    \item an identifier, \emph{e.g.}, ``beat'' or ``tag\_cal500'';
    \item schema declarations for the \emph{value} and \emph{confidence} fields;
    \item whether data should be encoded in \emph{dense} or \emph{sparse} form; and
    \item a brief plain-text description of the task.
\end{itemize}
The identifier is within \emph{Annotation} objects to specify which namespace they should be validated against.
The schema declarations for \emph{value} and \emph{confidence} are both optional, but can be used to impose constraints on the permissible
contents of an observation. 

This abstraction allows for both a more general set of supported tasks, in that there may be many \emph{tag} namespaces, 
and more precise task definitions for each specific namespace.
For instance, a valid \emph{tag\_cal500} annotation must have a value drawn from the correct vocabulary, whereas a \emph{tag\_open}
annotation may contain any string in its \emph{value} field; however, in both cases, the value must be a string, and this constraint was
not possible in the JAMS-0.1 schema.

With the namespace abstraction, it is possible for observations to have arbitrarily structured value and confidence fields.
\Cref{fig:thayer} provides a complete example namespace definition for \emph{mood\_thayer} annotations, in which each observed value is an ordered pair of numbers encoding \emph{valence}
and \emph{arousal} in the Thayer mood model.

For convenience, namespaces are grouped into high-level task categories by their identifiers.
We stress that this grouping is merely cosmetic, and there is no strict underlying hierarchy of tasks.
\Cref{tab:namespaces} lists the namespaces supported in JAMS v0.2.0.

Finally, namespaces are defined externally to the core schema, and new namespaces can be imported dynamically with no modifications to the JAMS implementation itself.
This makes it possible to develop and share custom annotation specifications.

\begin{table}
    \caption{Namespaces supported in JAMS v0.2.0.}\label{tab:namespaces}
    \centering
    \begin{tabular}{rl}
    \toprule
    Task group                  & Namespace\\
    \midrule
    \multirow{2}{*}{Beat}       & \texttt{beat}\\
                                & \texttt{beat\_position}\\
    \multirow{3}{*}{Chord}      & \texttt{chord}\\
                                & \texttt{chord\_harte}\\
                                & \texttt{chord\_roman}\\
    Key                         & \texttt{key\_mode }\\
    Lyrics                      & \texttt{lyrics}\\
    Mood                        & \texttt{mood\_thayer}\\
    Onset                       & \texttt{onset}\\
    Pattern                     & \texttt{pattern\_jku}\\
    \multirow{3}{*}{Pitch}      & \texttt{pitch\_class}\\
                                & \texttt{pitch\_hz}\\
                                & \texttt{pitch\_midi}\\
    \multirow{5}{*}{Segment}    & \texttt{segment\_open}\\
                                & \texttt{segment\_salami\_function}\\
                                & \texttt{segment\_salami\_upper}\\
                                & \texttt{segment\_salami\_lower}\\
                                & \texttt{segment\_salami\_tut}\\
    \multirow{5}{*}{Tag}        & \texttt{tag\_cal10k}\\
                                & \texttt{tag\_cal500}\\
                                & \texttt{tag\_gtzan}\\
                                & \texttt{tag\_medleydb\_instruments}\\
                                & \texttt{tag\_open}\\
    Tempo                       & \texttt{tempo}\\
    \bottomrule
    \end{tabular}
\end{table}

\begin{table}
    \caption{New namespaces planned for JAMS v0.2.1.}\label{tab:namespaces:0.2.1}
    \centering
    \begin{tabular}{rl}
    \toprule
    Task group                  & Namespace\\
    \midrule
    \multirow{2}{*}{Misc}       & \texttt{blob}\\
                                & \texttt{vector}\\
    Segment                     & \texttt{multi\_segment}\\
    \bottomrule
    \end{tabular}
\end{table}


\begin{figure}
    \begin{lstlisting}[language=json,title={mood\_thayer.json}]
{"mood_thayer":
    {
        "value": {
            "type": "array",
            "items": {"type": "number"},
            "minItems": 2,
            "maxItems": 2
        },
        "dense": false,
        "description": "Time-varying emotional measurements as ordered pairs of (valence, arousal)"
    }
}
\end{lstlisting}
\caption{An example namespace definition file for \emph{mood\_thayer}.  Each observed
value is an array of exactly two numbers, and observations are packed sparsely.  No
constraints are placed upon the \emph{confidence} field.\label{fig:thayer}}
\end{figure}


\section{Implementation}\label{sec:implementation}

To support the schema changes described in the previous section, the JAMS python 
implementation was dramatically revised in 0.2.

\subsection{Search}\label{sec:imp:search}
As described in \ref{sec:schema:namespace}, all annotation objects are now collected in a
single list at the top level.  This presents a difficulty for users: in the presence of
multiple annotations spanning various tasks, how can one efficiently select a specific
annotation?  A common use-case might be selecting only the annotations matching a given
task, \emph{e.g.}, finding all the \texttt{beat} annotations.  More advanced and general
examples are also possible, such as filtering by annotator or curator, or arbitrary
sandbox entries.

To address this general, common problem, we introduced the \texttt{JAMS.search()} method.
This method acts as a filter over the list of annotations, and performs a recursive
descent over the object hierarchy to find matching fields.  For example, to find all the
\texttt{beat} annotations, one simply needs to execute the following:
\begin{lstlisting}[language=python]
>>> jam = jams.load('filename.jams')
>>> anns = jam.search(namespace='beat')
\end{lstlisting}
The resulting \texttt{anns} object is a (possibly empty) collection of annotation objects
matching the query.  Multiple simultaneous query conditions are possible, and are 
interpreted disjunctively.
The following example finds all annotations that have either
\texttt{beat} as a namespace, or \emph{isophonics} as a corpus:
\begin{lstlisting}[language=python]
>>> anns = jam.search(namespace='beat',
...                   corpus='isophonics')
\end{lstlisting}

In fact, search results are provided as a list-like object that again implements 
\texttt{search()}, so that conjunctions are supported by successive queries.
To find annotations that match both the namespace and corpus fields, one could execute 
the following:
\begin{lstlisting}[language=python]
>>> anns = jam.search(namespace='beat')
>>> anns = anns.search(corpus='isophonics')
\end{lstlisting}


\subsection{Data frames}\label{sec:imp:dataframe}
The JAMS1 implementation provided a direct object mapping between the JSON representation
and its instantiation in Python.
Consequently, the code to access the elementa of a JAMS object is a simple traversal of the
data structure, \emph{e.g.}:
\begin{lstlisting}[language=python]
>>> ann = jam.beat[0]
>>> first_beat = ann.data[0].time
\end{lstlisting}
One advantage of this approach is that it would yield nearly identical code in any other
language (such as JavaScript)

However, in practice, working with data in this format can be somewhat cumbersome.
For example, evaluation scripts (such as mir\_eval~\cite{raffel2014}) typically expect
data in an array format.  This can be accomplished with some minor contortion by
iterating over the observations:
\begin{lstlisting}[language=python]
>>> all_beats = [o.time for o in ann.data]
\end{lstlisting}
More generally, certain common operations like thresholding or
label manipulation are simply easier with natively array-oriented representations.

Since JAMS2 encodes all annotation data in a table-friendly format, we instead opted to
provide a table-interface in the Python implementation.  This is accomplished by
translating annotation data fields into a Pandas data frame
object~\cite{mckinney-proc-scipy-2010} upon construction.
The choice of using a data frame (rather than a numpy array) carries several advantages:
\begin{itemize}
    \item labeled fields;
    \item heterogeneous data types;
    \item advanced query operations (join, merge, etc);
    \item missing value support; and
    \item temporal indexing.
\end{itemize}

Accessing individual observations in JAMS2 looks nearly identical to JAMS1
(once an annotation object has been selected):
\begin{lstlisting}[language=python]
>>> ann = jam.search(namespace='beat')[0]
>>> first_beat = ann.data.time[0]

# This would also work:
>>> first_beat = ann.data.loc[0].time

>>> all_beats = ann.data.time
\end{lstlisting}
However, the \texttt{ann.data} object itself can now be operated upon as an array or
data frame.

JAMS data frame objects interpret all \texttt{time} and \texttt{duration} fields as
\texttt{timedelta} types.  In addition to facilitating semantic validation ---
\texttt{time} and \texttt{duration} fields are enforced to contain non-negative values --- 
this enables pandas to efficiently align and resample multiple annotations with 
non-uniform timings.  Upon serialization, these values are converted back to raw floating
point representations in units of seconds.


\subsection{Dynamic namespaces}\label{sec:imp:namespaces}
\subsection{Validation}\label{sec:imp:validation}
\subsection{mir\_eval integration}\label{sec:imp:mireval}
\subsection{IO, compression, JAMZ}\label{sec:imp:compression}

\section{Future directions}\label{sec:future}

\subsection{Namespace conversions}
\subsection{Local namespaces and unstructured data}
\subsection{Partial annotations}
\subsection{Quick-view}

\bibliography{refs}

\end{document}
